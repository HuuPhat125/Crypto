## Diffie-Hellman Starter 1
### Solution
Do what the challenges wants you to do.

### Code

```python
print(pow(209, -1, 991))
```

## Diffie-Hellman Starter 2
### Solution
You brute-force to get the answer.

### Code
```python
def order(g, p):
	for i in range(2, p):
		if pow(g, i, p) == g:
			return i
	return p
		
p = 28151
for g in range(2,p):
	o = order(g, p) 
	if o == p: 
		print(g) 
		break
```

## Diffie-Hellman Starter 3
### Solution
Use `pow()` please.

### Code

```python
g = 2
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
a = 972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815

print(pow(g, a, p))
```

## Diffie-Hellman Starter 4
### Solution
Calculate $A^b \mod p$ and Alice will do the same with $\left({B, a, p}\right)$.

### Code

```python
A = 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601

b = 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720

p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

print(pow(A, b, p))
```

## Diffie-Hellman Starter 5
### Solution
First, calculate shared secret $A^b \mod p$. Then put all shared secret, iv and ciphertext to `decrypt.py` and run

## Parameter Injection
### Solution
Because you are the man who can read and change the message from Alice to Bob vice versa. So you can send to Bob random message and don't care about Bob's reply. After that send Alice `{"B": "0x01"}` because $1^{a} \mod p = 1$ and then you have shared secrect is 1. Use `decrypt.py` in Diffie-Hellman Starter 5 to decrypt.

### Code
```shell
k@k:~$ nc socket.cryptohack.org 13371

Intercepted from Alice: {"p": "0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff", "g": "0x02", "A": "0x56cfad49f8b300c3cd07f7316443438f207ef462139ec10db021379fc6be5b39fc4e8b1953a17399740f90214eaef6d504e2ccad0cdd6d971f6a8ec2f37d58f47a6b2bcba4921fa9e646cf19da91980d4cc7bd9627cb6ff94ec956aebd58d194233702aff44285e6bdf19614dcea89ed11a6bfa379d7d22f4bd77d4db3bcb40f00d5778ee4bf88bb71a31240b371a8b617c6607489b3024ddfdec5b7fdf4e8d0c8e07a740f07a4fd78cba008c0583c4dffd374b5f4950002b73711c02b1b7d4b"}

Send to Bob: {"p": "0x01", "g": "0x01", "A": "0x01"} 

Intercepted from Bob: {"B": "0x0"}

Send to Alice: {"B": "0x01"}

Intercepted from Alice: {"iv": "7fe6ab5b6572ad7eba0d1970a610916e", "encrypted_flag": "2c45af1150e551260525e33e7d4c38c27769ccb5ce99297ae8718fac5e571f55"}
```

## Export-grade
### Solution
First, choose DH64 for easiest. After that, we got $A, B, p, g$.
You can use `discrete_log(p, A, g)` to get $a$ and then shared secret is $B^a \mod p$.
Use `decrypt.py` to solve.
### Code
```shell
k@k:~$ nc socket.cryptohack.org 13379
Intercepted from Alice: {"supported": ["DH1536", "DH1024", "DH512", "DH256", "DH128", "DH64"]}

Send to Bob: {"supported": ["DH64"]}

Intercepted from Bob: {"chosen": "DH64"}

Send to Alice: {"chosen": "DH64"}

Intercepted from Alice: {"p": "0xde26ab651b92a129", "g": "0x2", "A": "0x71bd503db85c8a69"}
Intercepted from Bob: {"B": "0xcd0abfbbdf7db925"}
Intercepted from Alice: {"iv": "622269623bd6382fe4d7ac542951f944", "encrypted_flag": "5901469760c0ff6b578a77a56f848ca59d6c7015f9df1ce452fe71a2a8082fd7"}
```

## Static Client
### Solution
We know that Bob will compute the $B = g^b \mod p$ and the shared secret $s = A^b \mod p$ then send $B$ and $s$ to Alice. So we can send to Bob $p' = p, g' = A$ and don't care about $A$, Bob will compute $B = g'^{b} \mod p = A^b \mod p = s$. And that's how we get the shared secret, use it to decrype Alice's encrypted text.

### Code

```shell
k@k:~$ nc socket.cryptohack.org 13373

Intercepted from Alice: {"p": "0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff", "g": "0x02", "A": "0x14dd4766e622d2345b96774b97f668d253e38691e3ec7a45c54367709d869046d653ff980f72f77272dc3c14c037f01fa4af08c5c5ff65d698f117d1b1a65a53911102a668523cca232cbacfde4e743d546e52f2fcfbc847bf01ba9000845fdb1a58a6742befe6022ccf691334843a91835eab18c193a17a02523d5b9679b2452e7c1989d45bd9ca8118e8a7ea10c05434367a619285ea198a7cc6df147541f1b4f7dd6c4cde00d16f46a494b18139422cbd1f9bb6464594938c945bf360df4d"}

Intercepted from Bob: {"B": "0x8d79b69390f639501d81bdce911ec9defb0e93d421c02958c8c8dd4e245e61ae861ef9d32aa85dfec628d4046c403199297d6e17f0c9555137b5e8555eb941e8dcfd2fe5e68eecffeb66c6b0de91eb8cf2fd0c0f3f47e0c89779276fa7138e138793020c6b8f834be20a16237900c108f23f872a5f693ca3f93c3fd5a853dfd69518eb4bab9ac2a004d3a11fb21307149e8f2e1d8e1d7c85d604aa0bee335eade60f191f74ee165cd4baa067b96385aa89cbc7722e7426522381fc94ebfa8ef0"}

Intercepted from Alice: {"iv": "e971b684dd482c56d6c661f7c6f79d88", "encrypted": "21a6b39b8bf09efd8957d5c7722759033f6afc21b30d907a8e6073906b8804e3"}

Bob connects to you, send him some parameters: {"p": "0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff", "g": "0x14dd4766e622d2345b96774b97f668d253e38691e3ec7a45c54367709d869046d653ff980f72f77272dc3c14c037f01fa4af08c5c5ff65d698f117d1b1a65a53911102a668523cca232cbacfde4e743d546e52f2fcfbc847bf01ba9000845fdb1a58a6742befe6022ccf691334843a91835eab18c193a17a02523d5b9679b2452e7c1989d45bd9ca8118e8a7ea10c05434367a619285ea198a7cc6df147541f1b4f7dd6c4cde00d16f46a494b18139422cbd1f9bb6464594938c945bf360df4d", "A": "0xfffffffffff"}

Bob says to you: {"B": "0x2218f3092ec488d4c26a16afb703d3a2f29b1cbd1374a5610ea0fdbb5963d370062b734b003bb8c1fd4271191ffb5445b3ad6a082584770078a8f8da84f55313668d228a0163ec3fa280255914e57ac30e2f1581e452a4885d619a07701f9a080f12966da9593fadd4cde381aacfef7124ab85a31ac6873eb6595e0579d7de8f0052de2dd3952e1bf4c7c92d285091a6fb16b4d58c69967299d7bc65a9344bf96eb30b48e476d66680e14ba59c88b3d8af9bf508c6c83af5c1226becddd8c32e"}

Bob says to you: {"iv": "259bbab02c695222516e9e4ffa1fb004", "encrypted": "abe35c8df182ab09b781da839d51718b3dc6500ac1708898c32e59221be248f0c86038ee66d4a8bcc6a63f9588402d9740d9c3bc5d3d64038f4b34c28f908e09b96ed3780ca8d657f8f157191181ab1e"}
```


## Additive
### Solution
Let's review Diffie-Hellman in multiplicative group:
Alice and Bob publicly agree to use a modulus $p$ and base $g$ (which is a primitive root modulo $p$).
Alice chooses a secret integer $a$, then sends Bob  $A = g^a (\mod p)$
Bob chooses a secret integer $b$, then sends Alice $B = g^b (\mod p)$
Alice computes $s = B^a (\mod p)$
Bob computes $s = A^b (\mod p)$
Alice and Bob now share the secret $s$.

Diffie-Hellman in additive group is change all the exponent to multiply.

### Code
After get the all data from socket, you can give it into `decrypt.py` to solve.

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import inverse
import hashlib
from sympy.ntheory.residue_ntheory import discrete_log

def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))


def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('utf-8')
    else:
        return plaintext.decode('utf-8')
p = 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff
A = 0x190766d4be1c2ec1c00f7838764a46288c28567d5e093e49ef71587272f80bed58f8c47c70a99f4b0eceab6d659ce8d2c8475b10f93fc5123017fb54a875a9b18191af5dac0d857c28953fba4d10b2a1dfcb83bbb0f29bfa10fdb15ce8af2b8d441a00b1cf0f2e0634bb0aa912a9a6107b205b225a52a6d822ad7c31c402ae93a6d2d77b5664cae2703433170fdf1703abf7f30f353752ad9cc98db09f6f1e891e20535081cfe86f5e1415d5f2aca3956f2eb6691901d3e55cfcbe3f2a3a550b
g = 0x2
a = A * inverse(g, p)
B = 0x92092dfaafe2de9fa585c26f79aa763c1069cb6e37d0f68c655d89fc9e99f17703c9336558b8cd49bc72de084a2e7736644d7c79147ee4bd93c8bffe883a9442a2bbf269a07c9af81b56b5af1fe523d7201acd9636e52e3f0a07ae124e986d94560c044a9a62ae916ec89c4450c2a31a3b6c400d21b00bbb292611bf504d5a22282dc767dca91f0573da8fa35a8deaa1307bf272589af97052d6402b69c34313fa5d7a4c06d6cbca70b0e74979821cf09f5f581a2f3fb86c6f455863caa9f0b0

shared_secret = (a * B) % p

iv = "317c46f08dd3bbe5138d8b53163402ea"
ciphertext = "636a2cab48228912618557d1355cda5dc104839b1db454b5aa62c397c92dd876a56d13a3c291f4dfbfddfd37b837f5e0"

print(decrypt_flag(shared_secret, iv, ciphertext))
```

## Static Client 2
### Solution
It's clearly that Bob can regconize if $g = A$, so we have to modify $p$.
There is an attack called Pohlig-Hellman which, when used in Diffie-Hellman, can derive the key of a client. [Pohlig-Hellman](https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm) when used in a group with smooth order (smooth p) can solve the DLP (discrete logarithm problem).
Pohlig-Hellman will solve $B = g^b \mod p$ with a smooth p. An integer is $k$-smooth if it has no prime factors > $k$. And I discovered a good smooth p for you.

```sh
21161033472192524829557170410776298658794639108376130676557783015578090330844472167861788371083170940722591241807108382859295872641348645166391260040395583908986502774347856154314632614857393087562331369896964916313777278292965202780626304839725254323083321245935920345445760469315716688808181386083935737705284353395869520861742156127496385090743602309049820934917134755461873012945704938955132724663075880436995904093654709349552656965610546540372048421026608925808493978164019986593442564905462745669412326023291812269608558332157759989142549649265359278848084868920655698461242425344000000000000000000000000000000000000000000000000000000000000000000000000000001
```

Or

```python
0x72b20ce22e5616f923901a946b02b2ad0417882d9172d88c1940fec763b0cdf02ca5862cfa70e47fb8fd10615bf61187cd564a017355802212a526453e1fb9791014f070d77f8ff4dd54a6d1d58969293734e0b6bc22f3ceea788aa33be35eed4bdc1c8ceb94084399d98e13e69a2b9fa6c5583836a15798ba1a10edd81160a15662cdf587df6b816c570f9b11a466d1b4c328180f614e964f3a5ec61c3f2b759b21687a122f9faefc86fe69a3efd14829639596eb7f2de6eab6b444d06233d34d0651e6fed17db4d0025e58db7cad8824c3e93ed24df588a0a4530be2676e995f870172b9e765ec2886bce140000000000000000000000000000000000000000000000000000000000000000000000000000001
```
We got $B$ now, compute $b$ and then get the shared secret

## Script Kiddie
### Solution
Notice in the `generate_public_int` and `generate_shared_secret` function, `^` symbol is $XOR$ not exponent in Python. So we can take $a = g \oplus A$ and $s = a \oplus B$ and get shared secret.

### Code

```python
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import inverse
import hashlib
def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))
def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('utf-8')
    else:
        return plaintext.decode('utf-8')
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
g = 2
A = 539556019868756019035615487062583764545019803793635712947528463889304486869497162061335997527971977050049337464152478479265992127749780103259420400564906895897077512359628760656227084039215210033374611483959802841868892445902197049235745933150328311259162433075155095844532813412268773066318780724878693701177217733659861396010057464019948199892231790191103752209797118863201066964703008895947360077614198735382678809731252084194135812256359294228383696551949882
B = 652888676809466256406904653886313023288609075262748718135045355786028783611182379919130347165201199876762400523413029908630805888567578414109983228590188758171259420566830374793540891937904402387134765200478072915215871011267065310188328883039327167068295517693269989835771255162641401501080811953709743259493453369152994501213224841052509818015422338794357540968552645357127943400146625902468838113443484208599332251406190345653880206706388377388164982846343351
iv = 'c044059ae57b61821a9090fbdefc63c5'
encrypted_flag = 'f60522a95bde87a9ff00dc2c3d99177019f625f3364188c1058183004506bf96541cf241dad1c0e92535564e537322d7'
b = g ^ B
shared_secret = A ^ b
print(decrypt_flag(shared_secret, iv, encrypted_flag))
```

